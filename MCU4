/*
 * File:        MCU4
 * Author:      Matthew Filipek
 * Target PIC:  PIC32MX250F128B
 */



////////////////////////////////////
// clock AND protoThreads configure!
// You MUST check this file!
#include "config.h"
#include "pt_cornell_1_2.h"
#include <plib.h>

////////////////////////////////////
// graphics libraries
#include "tft_gfx.h"
#include "tft_master.h"

char buffer[60]; // string buffer
//static int speedTarget; // target fan speed


#define I2CBAUD 10000 //clock operating at 10kHz
#define BRG_VAL  ((PBCLK/2/I2CBAUD)-2)
#define I2CAddress 0x1F;



static int I2CDataIn;
static unsigned char config1 = 0x88;
static unsigned char Status1 = 0xFF;
static unsigned char Status2 = 0x00;
static unsigned int M7_PWM;//pin 2
static unsigned int M6_PWM;//pin 3
static unsigned int M5_PWM;//pin 4
static unsigned int M4_PWM;//pin 9
static unsigned int M3_PWM;//pin 6



static unsigned int CUR_SENSE;
//BIT7(MSB)= M7, BIT6 = M6
//BIT5 = M5, BIT4 = M4
//BIT3 = M3

static unsigned int Bat_Cutoff;

//---I2C Register Addresses---


//Config
#define ADDR_CLR_I2C_STATE 0xFF
#define ADDR_Config1  0x00 
/* BIT7(MSB) = CUR_Sense_EN
 * 
 * CUR_Sense_EN - If enabled, PWM duty cycles will be set to 0% when current
 * sense threshold is reached. Status1 reg holds information on which thresholds
 * have been tripped. To resume normal motor operation, coresponding Status2 
 * bits must be cleared
 * 
 * BIT6 = LowPowerShutoff_EN
 * 
 * LowPowerShutoff_EN - If set MCU will halt all motors if low battery signal received
 * 
 * BIT5 = MOTOR_HALT
 * 
 * MOTOR_HALT - If set, MCU will halt all motors 
 * 
 * BIT4 = RAMP_DOWN_EN
 * 
 * RAMP_DOWN_EN - MCU will set a maximum speed delta; any speed changes
 * that exceed this delta will be done gradually rather than
 * instantaneously
 *
 * BIT3 = MCU_TIMEOUT
 * 
 * MCU_TIMEOUT - MCU will set all motor efforts to 0 if no command has been received 
 * for 2 seconds
 * 
 *
 * Default state of config1 = 0x88
 */
#define CUR_SENSE_EN 0x80
#define MOTOR_HALT 0x20


//Read-only
#define ADDR_Status1  0x01
/*
 * BIT7(MSB) = ~BAT_CUTOFF
 * 
 * BAT_CUTOFF - Bit indicates the rover's battery is running low, 1 if
 * nominal, 0 if low

Default state of register = 0xFF
 */

#define ADDR_Status2  0x02
/*
 * BIT7(MSB) = M7_CUR
 * BIT6 = M6_CUR
 * BIT5 = M5_CUR
 * BIT4 = M4_CUR
 * BIT3 = M3_CUR
 * 
 * 
 * XX_CUR - Current sense threshold has been reached by the specified motor
 * motor will halt until bit is reset. 1 if threshold is reached

Default state of register = 0x00
 */
#define M7_CUR 0x80
#define M6_CUR 0x40
#define M5_CUR 0x20
#define M4_CUR 0x10
#define M3_CUR 0x08

//Motor addresses
#define ADDR_M3_PWM 0x10
#define ADDR_M4_PWM 0x11
#define ADDR_M5_PWM 0x12
#define ADDR_M6_PWM 0x13
#define ADDR_M7_PWM 0x14



//Motor Bank Addresses
#define ADDR_ALL_PWM 0x20


//// command array
static char cmd[30];
static int value;
static int count;

// === the fixed point macros ========================================
typedef signed int fix16;
#define multfix16(a,b) ((fix16)(((( signed long long)(a))*(( signed long long)(b)))>>16)) //multiply two fixed 16:16
#define float2fix16(a) ((fix16)((a)*65536.0)) // 2^16
#define fix2float16(a) ((float)(a)/65536.0)
#define fix2int16(a)    ((int)((a)>>16))
#define int2fix16(a)    ((fix16)((a)<<16))
#define divfix16(a,b) ((fix16)((((signed long long)(a)<<16)/(b))))
#define sqrtfix16(a) (float2fix16(sqrt(fix2float16(a))))
#define absfix16(a) abs(a)

// UART parameters
#define BAUDRATE 9600 // must match PC end
#define PB_DIVISOR (1 << OSCCONbits.PBDIV) // read the peripheral bus divider, FPBDIV
#define PB_FREQ SYS_FREQ/PB_DIVISOR // periperhal bus frequency

// useful ASCII/VT100 macros for PuTTY
#define clrscr() printf( "\x1b[2J")
#define home()   printf( "\x1b[H")
#define pcr()    printf( '\r')
#define crlf     putchar(0x0a); putchar(0x0d);
#define max_chars 50 // for input buffer

#define FOSC 60E6
#define PB_DIV 8
#define PRESCALE 256
#define T1_TICK (FOSC/PB_DIV/PRESCALE*64)

#define CONFIG (CN_ON | CN_IDLE_CON)
#define PINS (CN15_ENABLE)
#define PULLUPS (CN_PULLUP_DISABLE_ALL)

static struct pt pt_CSense;

static PT_THREAD(protothread_CSense(struct pt *pt)) {
    PT_BEGIN(pt);
    while (1) {
        
        if (config1 & 0x80) {
            if (mPORTBReadBits(BIT_3)) {
                M7_PWM = 0;
                SetDCOC1PWM(M7_PWM);
                Status2 |= 0x80;
            }
            if (mPORTBReadBits(BIT_1)) {
                M6_PWM = 0;
				SetDCOC2PWM(M6_PWM);
                Status2 |= 0x40;
            }
            if (mPORTAReadBits(BIT_3)) {
                M5_PWM = 0;
				SetDCOC3PWM(M5_PWM);
                Status2 |= 0x20;
            }
            if (mPORTBReadBits(BIT_4)) {
                M4_PWM = 0;
                SetDCOC5PWM(M4_PWM);
                Status2 |= 0x10;
            }
            if (mPORTAReadBits(BIT_4)) {
                M3_PWM = 0;
                SetDCOC4PWM(M3_PWM);                    
                Status2 |= 0x08;
            }
            
        }
        PT_YIELD_TIME_msec(10);

    }
    PT_END(pt);

}

// external interrupt

void __ISR(_EXTERNAL_0_VECTOR, ipl1) INT0Interrupt(void) {
    //tft_fillScreen(ILI9340_BLACK); //240x320 vertical display
    count++;

    // clear interrupt flag
    mINT0ClearIntFlag();
}

void __ISR(_TIMER_2_VECTOR, ipl2) Timer2Handler(void) { //empty ISR
    mT2ClearIntFlag(); //clear interrupt flag, if you forget to do this, the microcontroller will interrupt continuously
}

static int I2Cstate = 0;
static unsigned char I2C_request;

///////////////////////////////////////////////////////////////////
//
// Slave I2C interrupt handler
// This handler is called when a qualifying I2C events occurs
// this means that as well as Slave events
// Master and Bus Collision events will also trigger this handler.
//
///////////////////////////////////////////////////////////////////

void __ISR(_I2C_1_VECTOR, ipl3) _SlaveI2CHandler(void) {
    unsigned char temp;
    static unsigned int dIndex;

    // check for MASTER and Bus events and respond accordingly
    if (IFS1bits.I2C1MIF) {
        mI2C1MClearIntFlag();
        return;
    }
    if (IFS1bits.I2C1BIF) {//bus collision, reset I2C state machine
        I2Cstate = 0;
        mI2C1BClearIntFlag();
        return;
    }

    // handle the incoming message
    if ((I2C1STATbits.R_W == 0) && (I2C1STATbits.D_A == 0)) {
        // reset any state variables needed by a message sequence
        // perform a dummy read
        temp = SlaveReadI2C1();
        I2C1CONbits.SCLREL = 1; // release the clock
        I2Cstate = 0;
    } else if ((I2C1STATbits.R_W == 0) && (I2C1STATbits.D_A == 1)) {//data received, input to slave
        // writing data to our module
        I2CDataIn = SlaveReadI2C1();
        I2C1CONbits.SCLREL = 1; // release clock stretch bit
        
        if( I2Cstate == 0 && I2CDataIn != ADDR_CLR_I2C_STATE){
            I2Cstate = 1;
            I2C_request = I2CDataIn;
        }
        else if(I2Cstate == 1){
            switch(I2C_request){
                case ADDR_ALL_PWM:
                    if (I2CDataIn & 0x80) {
						mPORTBClearBits(BIT_13|BIT_14|BIT_15|BIT_11|BIT_7);
                        M3_PWM = (((int)((~I2CDataIn)+1))<<4);
                        M4_PWM = M3_PWM;
                        M5_PWM = M3_PWM;
                        M6_PWM = M3_PWM;
                        M7_PWM = M3_PWM;

                    } else {
                        mPORTBSetBits(BIT_13);
                        M3_PWM = ((int)I2CDataIn) << 4;
                        M4_PWM = M3_PWM;
                        M5_PWM = M3_PWM;
                        M6_PWM = M3_PWM;
                        M7_PWM = M3_PWM;
                    }
                    SetDCOC1PWM(M3_PWM);
					SetDCOC2PWM(M6_PWM);
					SetDCOC3PWM(M5_PWM);
					SetDCOC4PWM(M3_PWM);
					SetDCOC5PWM(M4_PWM);
                    break;

                case ADDR_M3_PWM :

                    if (((Status2 & M3_CUR) && (config1 & CUR_SENSE_EN)) || (config1 & MOTOR_HALT)) {
                        M3_PWM = 0;
                    }
                    else{
                    if (I2CDataIn & 0x80) {
						mPORTBClearBits(BIT_13);
                        M3_PWM = (((int)((~I2CDataIn)+1))<<4);

                    } else {
                        mPORTBSetBits(BIT_13);
                        M3_PWM = ((int)I2CDataIn) << 4;
                    }
                    }
                    SetDCOC4PWM(M3_PWM);
                    break;
                case ADDR_M4_PWM:
                    if (((Status2 & M4_CUR) && (config1 & CUR_SENSE_EN)) || (config1 & MOTOR_HALT)) {
                        M4_PWM = 0;
                    }
                    else{
                    if (I2CDataIn & 0x80) {
						mPORTBClearBits(BIT_14);
                        M4_PWM = (((int)((~I2CDataIn)+1))<<4);

                    } else {
                        mPORTBSetBits(BIT_14);
                        M4_PWM = ((int)I2CDataIn) << 4;
                    }
                    }
					SetDCOC5PWM(M4_PWM);
                    break;
                case ADDR_M5_PWM:
                    if (((Status2 & M5_CUR) && (config1 & CUR_SENSE_EN)) || (config1 & MOTOR_HALT)) {
                        M5_PWM = 0;
                    }
                    else{
                    if (I2CDataIn & 0x80) {
						mPORTBClearBits(BIT_15);
                        M5_PWM = (((int)((~I2CDataIn)+1))<<4);

                    } else {
                        mPORTBSetBits(BIT_15);
                        M5_PWM = ((int)I2CDataIn) << 4;
                    }
                    }
					SetDCOC3PWM(M5_PWM);
                    break;                     
                case ADDR_M6_PWM:                   
                    if (((Status2 & M6_CUR) && (config1 & CUR_SENSE_EN)) || (config1 & MOTOR_HALT)) {
                        M6_PWM = 0;
                    }
                    else{
                    if (I2CDataIn & 0x80) {
						mPORTBClearBits(BIT_11);
                        M6_PWM = (((int)((~I2CDataIn)+1))<<4);

                    } else {
                        mPORTBSetBits(BIT_11);
                        M6_PWM = ((int)I2CDataIn) << 4;
                    }
                    }
					SetDCOC2PWM(M6_PWM);
                    break;
                case ADDR_M7_PWM:
                    if (((Status2 & M7_CUR) && (config1 & CUR_SENSE_EN)) || (config1 & MOTOR_HALT)) {
                        M7_PWM = 0;
                    }
                    else{
                    if (I2CDataIn & 0x80) {
			mPORTBClearBits(BIT_7);
                        M7_PWM = (((int)((~I2CDataIn)+1))<<4);

                    } else {
                        mPORTBSetBits(BIT_7);
                        M7_PWM = ((int)I2CDataIn) << 4;
                    }
                    }
					SetDCOC1PWM(M7_PWM);
                    break;				
                case ADDR_Config1:
                    config1 = I2CDataIn;
					if(config1 & MOTOR_HALT){
						SetDCOC1PWM(0);
						SetDCOC2PWM(0);
						SetDCOC3PWM(0);
						SetDCOC4PWM(0);
						SetDCOC5PWM(0);
					}
					else{
						SetDCOC1PWM(M7_PWM);
						SetDCOC2PWM(M6_PWM);
						SetDCOC3PWM(M5_PWM);
						SetDCOC4PWM(M3_PWM);
						SetDCOC5PWM(M4_PWM);
					}
                    break;                   
                default:
                    break;
                    
            } 
            I2Cstate = 0;
        }
        
        
    } else if ((I2C1STATbits.R_W == 1) && (I2C1STATbits.D_A == 0)) {
        // read of the slave device, read the address
        temp = SlaveReadI2C1();
        dIndex = 0;
        SlaveWriteI2C1(0xF6);
    } else if ((I2C1STATbits.R_W == 1) && (I2C1STATbits.D_A == 1)) {
        // output the data until the MASTER terminates the
        // transfer with a NACK, continuing reads return 0
        if (dIndex == 0) {
            SlaveWriteI2C1(0x66);
            dIndex++;
        } else
            SlaveWriteI2C1(0);

    }

    mI2C1SClearIntFlag();
}

void InitI2C(void) {
    CloseI2C1();
    
    // Enable the I2C module with clock stretching enabled
    // define a Master BRG of 400kHz although this is not used by the slave
    OpenI2C1(I2C_SLW_DIS | I2C_ON | I2C_7BIT_ADD | I2C_STR_EN|I2C_SM_DIS, BRG_VAL); //48);
//    I2C1BRG = BRG_VAL;
//    I2C1CON = 0xD040;
//    I2C1CON &= !I2C_SM_EN;
//    I2C1CON |= 0x40;
    // set the address of the slave module
    I2C1ADD = I2CAddress;
    I2C1MSK = 0;
    // I2C1CON |= 0x8000;
    // configure the interrupt priority for the I2C peripheral
    mI2C1SetIntPriority(I2C_INT_PRI_3 | I2C_INT_SLAVE);

    // clear pending interrupts and enable I2C interrupts
    mI2C1SClearIntFlag();
    EnableIntSI2C1;
}

// === Main  ======================================================

void main(void) {
    SYSTEMConfigPerformance(sys_clock);//clock CPU at 40MHz

    // === I2C Init ================
    InitI2C();
    ANSELA = 0; //make sure analog is cleared
    ANSELB = 0;
    AD1CON2 = 0;
    mJTAGPortEnable(0);
    
    
    PT_setup();
    RPA0R = 0;
    RPA1R = 0;
    CM2CON = 0;
    CVRCON = 0x0000;
    ANSELA = 0; //make sure analog is cleared
    ANSELB = 0;
    count = 0;
    
    RPA0R = 0x05;//output compare 1
	RPA1R = 0x05;//output compare 2
	RPB0R = 0x05;//output compare 3
	RPB2R = 0x05;//output compare 4
	RPA2R = 0x06;//output compare 5
	
    
    //mPORTAClearBits(BIT_0);
    mPORTASetPinsDigitalIn(BIT_3|BIT_4);//CS5, CS3
    mPORTBSetPinsDigitalIn(BIT_1|BIT_3|BIT_4);//CS6, CS7, CS4
    
    mPORTASetPinsDigitalOut(BIT_0|BIT_1|BIT_2);//PWMs
    mPORTBSetPinsDigitalOut(BIT_0|BIT_2|BIT_7|BIT_11|BIT_15|BIT_14|BIT_13);//PWMs & DIR

    // external interrupt0:
    mINT0IntEnable(TRUE);
    mINT0SetIntPriority(INT_PRIORITY_LEVEL_1);

    OpenTimer2(T2_ON | T2_SOURCE_INT | T2_PS_1_1, 2000);
    ConfigIntTimer2(T2_INT_ON | T2_INT_PRIOR_2);

    // set up OC for PWM
    ConfigIntOC1(OC_INT_PRIOR_0 | EXT_INT_SUB_PRI_2);
	ConfigIntOC2(OC_INT_PRIOR_1 | EXT_INT_SUB_PRI_2);
    ConfigIntOC3(OC_INT_PRIOR_2 | EXT_INT_SUB_PRI_2);
    ConfigIntOC4(OC_INT_PRIOR_3 | EXT_INT_SUB_PRI_2);
    ConfigIntOC5(OC_INT_PRIOR_4 | EXT_INT_SUB_PRI_2);

	
	
    OpenOC1(OC_ON | OC_TIMER2_SRC | OC_PWM_FAULT_PIN_DISABLE, 0, 0);
    OpenOC2(OC_ON | OC_TIMER2_SRC | OC_PWM_FAULT_PIN_DISABLE, 0, 0);
    OpenOC3(OC_ON | OC_TIMER2_SRC | OC_PWM_FAULT_PIN_DISABLE, 0, 0);
    OpenOC4(OC_ON | OC_TIMER2_SRC | OC_PWM_FAULT_PIN_DISABLE, 0, 0);
    OpenOC5(OC_ON | OC_TIMER2_SRC | OC_PWM_FAULT_PIN_DISABLE, 0, 0);

    
    // init the threads


    INTEnableSystemMultiVectoredInt();


    //round robin thread schedule
    while (1) {
        PT_SCHEDULE(protothread_CSense(&pt_CSense));
    }
} // main


// === end  ======================================================
